# 46. Permutations

## Condition

Given a collection of **distinct** integers, return all possible permutations.

**Example:**

```
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

## Условие

Дана коллекция отличающихся целых чисел. Вернуть все возможные *permutation*'s (перестановки).

**Пример:**

```
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

## 

## Решение 1. Сведение задачи к более простой путем удаления элемента

[Combination](https://github.com/parshikovpavel/cheat-sheets/blob/master/Algorithm.md#combination)

Связано с 1 объяснением количества *permutation*'s *n* различных объектов:

- (1 объяснение, 1 решение) – мы выбираем 1-ый элемент из *(n)* элементов (т.е. всего возможно *(n)* вариантов выбора 1-го элемента). После этого убираем этот элемент из *sequence*, делаем *permutation*'s оставшихся *(n-1)* элемента. 2-ой элемент мы можем выбрать из оставшихся *(n-1)* элементов, третий из оставшихся (n-2) элементов и так далее. 

Это дает нам общее количество *n × (n-1) × (n-2)... × 2 × 1 = n!* *permutation*'s.

Необходимо брать по очереди каждый элемент из *sequence* из *(n)* элементов и ставить его в конец *sequence*. Затем уменьшаем *sequence* до *n-1* элементов, и делаем все возможные *permutation*'s с ними. В итоге 1-й элемент, который стоит в конце *sequence*, будет присоединен ко всем *permutation*'s из *(n-1)* элемента.

Пример для sequence `[1, 2, 3]`:

```
[2, 3, 1], # [1, 2, 3] -> [3, 2, 1] -> [2, 3, 1]
[3, 2, 1], # [1, 2, 3] -> [3, 2, 1] -> [3, 2, 1]
[3, 1, 2], # [1, 2, 3] -> [1, 3, 2] -> [3, 2, 1]
[1, 3, 2], # [1, 2, 3] -> [1, 3, 2] -> [1, 3, 2]
[2, 1, 3], # [1, 2, 3] -> [1, 2, 3] -> [2, 1, 3]
[1, 2, 3], # [1, 2, 3] -> [1, 2, 3] -> [1, 2, 3]
```